# [CSAPP] 예외적인 제어흐름, exceptional control flow(ch.8)

### (참고) 이 내용은 교재에 있는 내용들을 요약한 내용이 아니라, 정리한 내용들입니다. 
함축적이지 않고 최대한 이해할 수 있게 늘어 놓았습니다.

> + *시작하기 전,* *교재를 사진찍어달라고 하셔서 다운로드 주소를 첨부합니다. 

첨부 파일 :* ( *예외적인 제어흐름.pdf* )
> 
> 
> [iCloud.com](https://www.icloud.com/iclouddrive/0e7h3C-0i2om-10a1d3scridA)
> 

# 8.0. Introduction

## 🔱 예외적인 제어흐름 (Exceptional Control Flow, ECF)

---

### → 제어이동(Control Transfer), 제어흐름(Control Transfer)

프로세서에 전원을 처음 공급하는 시점부터 전원을 끌 때까지 프로그램 카운터(PC)는 다음과 같은 값을 갖습니다. 
→ 인스트럭션 I(k)에 대응되는 주소가 a(k)이다. (사진 참조)

![Untitled](%5BCSAPP%5D%20%E1%84%8B%E1%85%A8%E1%84%8B%E1%85%AC%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%8C%E1%85%A6%E1%84%8B%E1%85%A5%E1%84%92%E1%85%B3%E1%84%85%E1%85%B3%E1%86%B7,%20exceptional%20control%20%20458595bca41b4f01abcbd17721e83abe/Untitled.png)

a(k) ~ a(k+1)로의 전환은 `제어이동(Control Transfer)`이라고 부릅니다. 

그림과 같이 프로그램이 실행되는 동안 명령어가 어떻게 실행되는지도 `제어흐름(Control Transfer)` 또는 `프로세서의 제어흐름`이라고 부릅니다. 

---

### → 제어흐름(Control Transfer)의 양상은 크게 세 종류 입니다.

1. **점진적인 제어흐름** : 첫번째 유형의 제어흐름은 **가장 간단하고 일반적 형태**이다. 각 명령어(I_k와 I_k+1)가 메모리에 연속적으로 저장되어 있어 순차적으로 실행됩니다. 이는 프로그램이 기본적인 실행순서에 따라 진행되는 경우로, 대부분의 시간을 차지하는 `제어흐름`입니다.
2. **갑작스런 변화를 가지는 제어흐름** : 두번째 유형의 제어흐름은 **일반적인 점진적인 흐름에 갑작스러운 변화가 발생하는 경우**입니다. 예를 들어, jump, call, return과 같은 프로그램 명령어를 사용하여 현재 실행 위치(I_k)와 인접하지 않은 다른 명령어(I_k+1)로 제어흐름을 전환합니다. (인접해 있지 않은 case인것!) 이러한 명령어들은 프로그램 변수등에 의한 내부 프로그램 상태의 변화에 반응하여 프로그램이 적절하게 동작하도록 하는데 사용됩니다.
3. 예외적인 제어흐름 : 세번째 유형의 제어흐름은 **예외 상황 또는 시스템 상태의 변화에 반응하여 제어흐름이 갑자기 변하는 경우**를 가리킵니다. 이러한 제어흐름을 우리는 `예외적인 제어흐름, exceptional control flow(ECF)` 라고 부른다. 예외적인 제어 흐름은 컴퓨터 시스템의 모든 수준(하드웨어, 운영체제, 응용 프로그램)에서 발생한다.
    
    > **모든 수준에서 ECF는 발생한다! → 모든 수준의 ECF | CS.APP - p.694**
    
    **→ 하드웨어 (Hardware) :** 
    *하드웨어 수준에서는 하드웨어에 의해서 검출되는 이벤트들은 `예외 핸들러(Exception handler)`로 갑작스런 제어이동을 발생시킨다.*
    **→ 운영체제 (OS) :**
    *운영체제 커널 수준의 `문맥전환(context switch)`를 통해서 사용자 프로세스에서 다른 프로세스로 제어가 이동한다.*
    **→ 응용 프로그램(Application) :**
    *1. 프로세스는 시그널을 수신하는 곳에 있는 시그널 핸들러로 제어를 급격히 이동하는 다른 프로세스로 시그널을 보낼 수 있다.
    2. 개별 프로그램은 일반적인 스택 운영을 회피하고 다른 함수 내 임의의 위치로 비지역성 점프를 하는 방법으로 에러에 대응할 수 있다.*
    > 

---

### →  프로그래머로서 ECF를 이해하는 여러가지 중요한 이유가 있다 : (CS.APP - p.694-5)

- **ECF를 이해하면 중요한 시스템 개념을 이해하는 데 도움이 된다.**
    - ECF는 운영체제가 입출력, 프로세스, 가상메모리를 구현하기 위해 사용하는 기본 메커니즘이다.
    - 이런 중요한 아이디어들을 본격적으로 이해하려면 ECF를 이해할 필요가 있다
- **ECF를 이해하면 어떻게 응용 프로그램들이 운영체제와 상호작용하는지를 이해하는 데 도움이 된다.**
    - 응용 프로그램은 `트랩, Trap` 또는 `시스템 콜, system call` 이라고 알려진 ECF의 한 가지 형태를 사용해서 운영체제로부터 서비스를 요청한다.
        - 예를 들어, 데이터를 디스크에 쓰거나, 네트워크에서 데이터를 읽거나, 새로운 프로세스를 만들거나, 현재 프로세스를 종료시키는 등의 일은 모두 응용 프로그램이 시스템 콜을 호출해서 이루어진다. 기본 시스템 콜 메커니즘을 이해하면 어떻게 이러한 서비스들이 응용 프로그램에 제공되는지 이해하는데 도움이 된다.
- **ECF를 이해하면 재미있는 새로운 응용 프로그램 작성에 도움이 된다.**
    - 운영체제는 새로운 프로세스를 만들거나, 프로세스가 종료하기를 기다리거나, 다른 프로세서에게 시스템 내의 예외 이벤트를 알리거나, 이러한 이벤트를 감지하고 반응하는 등의 작업을 위한 강력한 ECF 메커니즘을 응용 프로그램들에게 제공한다. 만일 이 ECF 메커니즘들을 이해한다면, 이들을 사용해서 Unix 쉘과 웹 서버 같은 흥미로운 프로그램을 작성할 수 있다.
- **ECF를 이해하면 동시성을 이해하는 데 도움이 된다.**
    - ECF는 컴퓨터 시스템에서 `동시성`을 구현하는 기본 메커니즘이다.
    - 다음은 모두 동시성이 적용된 사례들이다. ECF를 이해하는 것은 동시성을 이해하는 첫 단계이다.
        - 실행시간이 중첩되는 프로세스, 쓰레드, 응용 프로그램들의 실행을 가로채는 `예외 처리 핸들러`와 응용 프로그램의 실행을 가로채는 `시그널 핸들러`.
    
    <aside>
    ❓ **동시성(Concurrency) :** 
    컴퓨터 시스템에서 여러작업이 동시에 실행되는 것을 의미합니다. 동시성은 여러 작업이 동시에 진행되는 것처럼 보이도록 만들어 줍니다. 이는 실제로 여러 작업이 동시에 실행되는 것이 아닌, 작업들이 빠르게 번갈아 가며 실행되는 것.
    
    </aside>
    
- **ECF를 이해하면 소프트웨어적인 예외상황이 어떻게 동작하는지 이해하는 데 도움이 될 것이다.**
    - C++, 자바는 try, catch, throw 문장을 통해, 소프트웨어 예외 메커니즘을 제공한다. 소프트웨어 예외는 프로그램이 에러 발생 시에 `비지역성(nonlocal) 점프` (즉, 일반적 call/return 스택 방식에 위배되는 점프)를 하도록 해준다.
    - 비지역성 점프는 응용 프로그램 수준의 ECF이며, C에서는 setjmp, longjmp함수로 제공된다.
    - 이들 하위 함수들을 이해하면 상위 소프트웨어 예외가 어떻게 구현 되는지 이해하는데 도움이 된다.
        - 이러한 Low-level의 함수(setjmp, longjmp)를 이해하면 소프트웨어 수준의 High-level 예외를 이해할 수 있게 된다.

---

### → 마무리

> CSAPP은 1-7장에서 시스템에 대한 여러분의 학습은 응용 프로그램이 하드웨어와 어떻게 상호작용하는지에 관한 것이었다.
> 
> 
> 이번 장은 응용 프로그램이 운영체제와 어떻게 상호작용하는지 배우기 시작하게 되는 측면에서 전환점이라고 볼 수 있다.
> 

운영체제, 하드웨어, 응용프로그램들의 상호작용들은 모두 ECF 중심으로 돌아간다. 앞으로 시작되는 8장에서는 모든 수준에 존재하는 ECF의 다양한 형태를 설명합니다.

> **이번 장에서 설명하게 될 내용**
> 
1. *하드웨어와 운영체제의 교차점에 놓인 예외상황(8.1)*
2. *응용 프로그램에게 운영체제 내부로 엔트리 포인트를 제공하는 예외적인 System Call(8.3)*
3. *응용 프로그램과 운영체제의 교차점에 위치한 프로세스와 시그널(8.4~8.5)*
    1. *비지역성 점프에 대해서 설명하는데, ECF의 응용 프로그램 수준의 형태(8.6)*

# 8.1. 예외 상황(Exceptional situation)

<aside>
👶🏻 예외상황은 부분적으로 하드웨어와 운영체제에 의해서 구현된 예외적인 제어 흐름의 한가지 형태이다.

</aside>

![예외 핸들러의 처리과정 : 1. I_curr으로 return / 2. I_next으로 return / 3. abort 루틴(프로그램 종료)](%5BCSAPP%5D%20%E1%84%8B%E1%85%A8%E1%84%8B%E1%85%AC%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%8C%E1%85%A6%E1%84%8B%E1%85%A5%E1%84%92%E1%85%B3%E1%84%85%E1%85%B3%E1%86%B7,%20exceptional%20control%20%20458595bca41b4f01abcbd17721e83abe/Untitled%201.png)

예외 핸들러의 처리과정 : 1. I_curr으로 return / 2. I_next으로 return / 3. abort 루틴(프로그램 종료)

`예외 상황`은 어떤 프로세스 상태의 변화에 대한 대응으로, 제어흐름의 갑작스런 변화입니다. 위 그림은 기본 아이디어를 보여줍니다.

그림에서 프로세서는 어떤 명령어 I_curr을 실행하고 있을때 프로세서 상태에 중요한 변화가 일어나고 있다. 이 상태는 프로세서 내 다양한 비트들과 신호들로 인코드된다. 상태 변화는 이벤트로 알려져 있다. 이 이벤트는 현재 인스트럭션의 실행에 직접적으로 관련될 수 있습니다. 반면, 이벤트는 현재 인스트럭션의 실행과 관련이 없을  수 있다.

어느 경우이든지 프로세서가 이벤트가 발생했다는 것을 감지하면, `예외 테이블`이라고 하는 점프 테이블을 통해서 이 특정 종류의 이벤트를 처리하기 위해 특별히 설계된 운영체제 서브루틴(예외처리 핸들러)으로 `간접 프로시저 콜`을 하게 된다.

<aside>
❓ - **간접 프로시저 콜 :** 함수 호출 시 함수의 주소를 포인터나 참조로 전달하여 실행 흐름을 다른 함수로 전환하는 메커니즘
- **인스트럭션 :** 명령어

</aside>

예외처리 핸들러가 처리를 끝마치면, 예외상황을 발생시킨 이벤트의 종류에 따라서 다음과 같은 세 가지 중의 한 가지 일이 발생한다.

1. 핸들러는 제어를 현재 인스트럭션 I_curr로 돌려준다. 이 인스트럭션은 이벤트가 발생했을 때 실행되고 있던 인스트럭션을 말한다.
2. 핸들러는 제어를 I_next로 돌려주는데, 이 인스트럭션은 예외상황이 발생하지 않았더라면 다음에 실행되었을 인스트럭션이다.
3. 핸들러는 중단된 프로그램을 종료한다.

# 8.1.1. 예외 처리(Exception handling)

예외상황은 이해하기 어려울 수 있는데, 그것은 이들을 처리하려면 HW와 SW가 긴밀하게 협력해야 하기 때문이다. 어떤 컴포넌트가 어떤 일을 수행하는지에 대해서 혼동하기가 쉽다.

![Untitled](%5BCSAPP%5D%20%E1%84%8B%E1%85%A8%E1%84%8B%E1%85%AC%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%8C%E1%85%A6%E1%84%8B%E1%85%A5%E1%84%92%E1%85%B3%E1%84%85%E1%85%B3%E1%86%B7,%20exceptional%20control%20%20458595bca41b4f01abcbd17721e83abe/Untitled%202.png)

한 시스템 내에서 가능한 예외 상황의 종류마다 중복되지 않는 양의 정수를 예외번호로 할당하고 있다. **이 숫자들의 일부는 프로세서 설계자가 부여한 것이다. 나머지 번호는 운영체제 커널(운영체제의 메모리가 상주하는 부분) 설계자가 할당한다.** 

(전자의 예) divide by zero(0으로 나누기 연산), 페이지 오류(Page Fault), 메모리 접근 위반, breakpoint, 산술연산 오버플로우가 포함된다.

(후자의 예) 시스템 콜, 외부 I/O 디바이스로부터의 `인터럽트(Interrupt)`가 포함된다.

운영체제는 시스템 부팅시 `예외 테이블(Exception Table)`을 메모리에 할당 초기화한다. 여기에는 각 예외에 해당하는 예외 핸들러의 주소들이 저장된다. 위의 사진이 예외 테이블의 예이다.

런타임(시스템이 프로그램을 실행하고 있을 때)에 **프로세서는 이벤트가 발생했다는 것을 감지하고, 대응되는 예외번호 k를 결정한다**. 프로세서는 그 후에 예외 테이블의 엔트리 k를 통해서 간접 프로시저 콜을 하는 방법으로 예외상황을 발생시킨다. 예외번호는 예외 테이블에서 인덱스이며, 이 테이블의 시작주소는 `예외 테이블 베이스 레지스터(Exception Table Base Register)`라는 특별한 CPU 레지스터에 저장되어 있다.

![Untitled](%5BCSAPP%5D%20%E1%84%8B%E1%85%A8%E1%84%8B%E1%85%AC%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%8C%E1%85%A6%E1%84%8B%E1%85%A5%E1%84%92%E1%85%B3%E1%84%85%E1%85%B3%E1%86%B7,%20exceptional%20control%20%20458595bca41b4f01abcbd17721e83abe/Untitled%203.png)

`예외상황`(”예외 핸들러의 호출”)은 `프로시저 콜`(”일반적인 함수 호출”)과 유사하지만 일부 중요한 차이점이 있다.  그러나 이 둘은 다음과 같이 중요한 몇 가지의 차이점을 가지고 있다. 예외 처리를 제대로 이해하기 위해선 이 둘의 차이를 이해하는 것이 매우 중요하다.

- 스택에 푸시하는 복귀 주소가 **현재 명령어(I_curr)의 주소일 수도, 다음 명령어(I_next)의 주소일 수도 있다.**
- **복귀 주소뿐만 아니라 다른 추가적인 프로세서 상태 정보도 스택에 푸시**한다. 이는 예외 핸들러가 리턴할 때 모든 프로세서 상태 정보를 원래대로 되돌려 놓기 위함이다. 실제로, x86-64 CPU는 예외 핸들러 호출 시 컨디션 코드 등의 프로세서 상태 정보를 저장하고 있는 EFLAGS라는 레지스터의 값을 스택에 푸시한다. 이렇게 하면 예외 핸들러가 리턴하고 돌아왔을 때 원래 프로그램은 아무 일이 없었던 것처럼 실행을 재개할 수 있다.
- **커널 모드**로 실행된다. 즉, 일반적인 함수와 달리 예외 핸들러는 시스템 자원들에 대한 접근 권한을 갖는다. 따라서 위에서 언급했던 데이터들도 유저 스택이 아닌 **커널 스택**에 푸시가 된다. (예외 핸들러가 리턴할 때 모든 프로세서 상태 정보를 원래대로 되돌려 놓기 위함이다.)

일단 하드웨어가 예외 발생을 감지하여 예외 핸들러의 호출까지 마치고 나면, 나머지 작업은 소프트웨어(예외 핸들러의 처리)에게 맡긴다. 그리고 **처리를 끝낸 예외 핸들러는 예외 종류에 따라 원래 프로그램의 실행 흐름으로 돌아가거나 abort 루틴으로 리턴하여 해당 프로그램을 종료시킨다.** 만약 돌아가야 하는 상황이라면, "*Return from Interrupt*"라는 특별한 명령어를 실행하여 원래 프로그램의 실행 흐름으로 돌아가도록 한다. 이 명령어는 스택에 푸시되어 있는 복귀 주소와 각종 프로세서 상태 정보를 팝 하여 원래대로 되돌려 놓고, (유저 모드로 돌아가는 경우라면) 현재 프로세서의 상태를 유저 모드로 바꿔주는 역할을 수행한다.

# 8.1.2.  예외 종류(Exception classes)

> `Interrupt`와 `Trap(System Call)`은 이름 그대로 부르고 나머지를 묶어서 예외라고 합니다.
예외 상황은 네가지 종류로 구분할 수 있다. `인터럽트`, `트랩`, `오류 fault`, `중단 abort` 밑의 테이블은 그 특징들을 요약한 것이다.
> 

![Untitled](%5BCSAPP%5D%20%E1%84%8B%E1%85%A8%E1%84%8B%E1%85%AC%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%8C%E1%85%A6%E1%84%8B%E1%85%A5%E1%84%92%E1%85%B3%E1%84%85%E1%85%B3%E1%86%B7,%20exceptional%20control%20%20458595bca41b4f01abcbd17721e83abe/Untitled%204.png)

![Untitled](%5BCSAPP%5D%20%E1%84%8B%E1%85%A8%E1%84%8B%E1%85%AC%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%8C%E1%85%A6%E1%84%8B%E1%85%A5%E1%84%92%E1%85%B3%E1%84%85%E1%85%B3%E1%86%B7,%20exceptional%20control%20%20458595bca41b4f01abcbd17721e83abe/Untitled%205.png)

## 인터럽트(Interrupt)

---

인터럽트는 프로세서 외부에 있는 입출력 디바이스로부터의 시그널의 결과로 `비동기적`으로 발생한다. 하드웨어 인터럽트는 비동기적이며, 즉 특정 인스트럭션을 실행해서 발생한 것이 아니라는 의미에서 그렇다 하드웨어 인터럽트를 위한 예외 핸들러는 종종 인터럽트 핸들러라고 부른다.

![(1) 현재 명령어 실행 중에 인터럽트 핀이 High 상태로 전환
(2) 현재 명령어가 완료된 후에 제어가 핸들러로 전달된다.
(3) 인터럽트 핸들러가 실행된다.
(4) 핸들러가 다음 명령어로 돌아간다.](%5BCSAPP%5D%20%E1%84%8B%E1%85%A8%E1%84%8B%E1%85%AC%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%8C%E1%85%A6%E1%84%8B%E1%85%A5%E1%84%92%E1%85%B3%E1%84%85%E1%85%B3%E1%86%B7,%20exceptional%20control%20%20458595bca41b4f01abcbd17721e83abe/Untitled%206.png)

(1) 현재 명령어 실행 중에 인터럽트 핀이 High 상태로 전환
(2) 현재 명령어가 완료된 후에 제어가 핸들러로 전달된다.
(3) 인터럽트 핸들러가 실행된다.
(4) 핸들러가 다음 명령어로 돌아간다.

현재의 인스트럭션이 실행을 완료한 후에, 프로세서는 인터럽트 핀이 high로 올라갔다는 것을 발견하고 시스템 버스에서 예외번호를 읽으며, 적절한 인터럽트 핸들러를 호출한다. 핸들러가 리턴할 때, 제어를 다음 인스트럭션으로 돌려준다.(즉, 제어흐름에서 인터럽트가 발생하지 않았다면 현재 인스트럭션 다음에 왔을 인스트럭션). 그 효과는 프로그램이 인터럽트가 마치 발생하지 않았던 것처럼 계속해서 실행되는 것이다.

나머지 예외의 종류들(트랩, 오류, 중단)은 지금의 인스트럭션을 실행한 결과로 동기적으로 일어난다.

<aside>
👊🏻 **→ 동기? 비동기?**
동기 : 순차적으로 실행, 한 작업이 완료되지 않으면 다음 작업이 시작되지 않는다.
비동기 : 병렬적으로 실행, 작업의 완료 여부를 기다리지 않고 실행한다.

</aside>

## 트랩과 시스템 콜(Trap, System Call)

---

![(1) 응용 프로그램이 System call 을 호출. → (2) 프로그램 실행흐름이 핸들러로 전달된다. → (3) Trap 핸들러가 실행 → (4) 핸들러가 시스템 콜을 처리한 후, 해당 시스템 콜을 호출한 명령어 다음의 명령어로 돌아간다.](%5BCSAPP%5D%20%E1%84%8B%E1%85%A8%E1%84%8B%E1%85%AC%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%8C%E1%85%A6%E1%84%8B%E1%85%A5%E1%84%92%E1%85%B3%E1%84%85%E1%85%B3%E1%86%B7,%20exceptional%20control%20%20458595bca41b4f01abcbd17721e83abe/Untitled%207.png)

(1) 응용 프로그램이 System call 을 호출. → (2) 프로그램 실행흐름이 핸들러로 전달된다. → (3) Trap 핸들러가 실행 → (4) 핸들러가 시스템 콜을 처리한 후, 해당 시스템 콜을 호출한 명령어 다음의 명령어로 돌아간다.

`트랩`은 의도적인 예외상황으로, 어떤 특정 인스트럭션을 실행한 결과로 발생한다. 인터럽트 핸들러와 마찬가지로 트랩 핸들러는 제어를 다음 인스트럭션으로 리턴한다. 트랩의 가장 중요한 사용은 시스템 콜이라고 알려진 사용자 프로그램과 커널 사이의 프로시저(*일련의 작업을 수행하기 위한 코드 블럭 or 함수)와 유사한 인터페이스를 제공하는 것이다.

사용자 프로그램은 파일을 읽거나(read), 새로운 프로세스를 만들거나(fork), 새 프로그램을 로드하고(execve), 현재 프로세스를 종료하는 등의 서비스를 종종 커널에게 요청할 필요가 있다. 이러한 커널 서비스의 제한된 접근을 하기 위해서 프로세서는 특별한 “n” 인스트럭션을 제공하며, 사용자 프로그램이 서비스 n을 요청하고자 할 때 사용자 프로그램이 사용할 수 있는 인스트럭션이다.

프로그래머의 관점에서 시스템 콜은 보통의 함수 호출과 동일하다. 그렇지만 실제 구현은 매우 다르다!

시스템 콜은 커널 모드에서 돌아가며, 이로 인해 커널 내에서 정의된 스택에 접근하며, 특권을 가진 인스트럭션을 실행할 수 있도록 해준다.

## 오류 (Fault)

---
